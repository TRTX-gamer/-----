/*
08_串口通信
    功能
        利用定时器进行精准的秒表计时,利用动态数码管进行144hz刷新显示时钟
        同时，与电脑串口通信，输入或者输出时间数据
    目的
        1 学习串口通信
        2 复习计时器
        3 复习中断
*/

#include "reg52.h"

////////////////////////////////////////////////////////////////////////////////
typedef unsigned int u16;
typedef unsigned char u8;

sbit LSA = P2 ^ 2;
sbit LSB = P2 ^ 3;
sbit LSC = P2 ^ 4;

////////////////////////////////////////////////////////////////////////////////
u8 code smgduan[10] = {0X3F, 0X06, 0X5B, 0X4F, 0X66, 0X6D, 0X7D, 0X07, 0X7F, 0X6F}; // 显示0~9的值
u8 smg[8] = {0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00, 0X00};                       // 记录八段数码管的显示数据
u8 sss = 0, sec = 0, min = 0, h = 0;                                                // 次数,秒，分 ,小时
u16 ssec = 0;                                                                       // 毫秒
u8 TransmitDate[8], ReceiveDate[8], Tsec = 0, Rsec = 0;                             // 发送数据,接受数据,发送次数，接收次数

////////////////////////////////////////////////////////////////////////////////
void Timer0Init(u8 x);              // 定时器0初始化函数
void UsartInit(u8 x);               // 串口通信与定时器1初始化函数
void Delay(u16 i);                  // 延时函数
void DisplayDelay(u8 smgxianshi[]); // 显示和延时函数

////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
* 函 数 名      : main
* 函数功能      : 主函数
* 输    入      : 
* 输    出      : 
*******************************************************************************/
void main(void)
{
    u8 temp0 = 1, temp1 = 1;

    Timer0Init(1); // 初始化计时器0
    UsartInit(1);  // 初始化串口通信与定时器1

    while (1)
    {
        if (sec != temp0 && Tsec != temp1) // 判断秒数和发送次数是否发生改变
        {
            temp1 = Tsec;

            switch (Tsec)
            {
            case 1:
                SBUF = 0X07;
                //SBUF = (h / 10) % 10 || 0X30;
                break;
            case 2:
                SBUF = 0X02;
                //SBUF = h % 10 || 0X30;
                break;
            case 3:
                SBUF = 0X2E;
                break;
            case 4:
                SBUF = 0X03;
                //SBUF = (min / 10) % 10 || 0X30;
                break;
            case 5:
                SBUF = 0X04;
                //SBUF = min % 10 || 0X30;
                break;
            case 6:
                SBUF = 0X2E;
                break;
            case 7:
                SBUF = 0X05;
                //SBUF = (sec / 10) % 10 || 0X30;
                break;
            case 8:
                SBUF = 0X06;
                //SBUF = sec % 10 || 0X30;
                break;
            case 9:
                SBUF = 0X20;
                Tsec = 1;
                temp0 = sec;
                break;
            }
        }
        if (Rsec == 8) // 处理接收到的八个字节
        {
            h = (ReceiveDate[0] % 16) * 10 + ReceiveDate[1] % 16;
            min = (ReceiveDate[2] % 16) * 10 + ReceiveDate[3] % 16;
            sec = (ReceiveDate[4] % 16) * 10 + ReceiveDate[5] % 16;
            ssec = ((ReceiveDate[6] % 16) * 10 + ReceiveDate[7] % 16) * 10;
            Rsec = 0;
        }

        smg[7] = smgduan[(h / 10) % 10];          // 时间数据处理
        smg[6] = smgduan[h % 10], smg[6] |= 0X80; // 加上dp
        smg[5] = smgduan[(min / 10) % 10];
        smg[4] = smgduan[min % 10], smg[4] |= 0X80;
        smg[3] = smgduan[(sec / 10) % 10];
        smg[2] = smgduan[sec % 10], smg[2] |= 0X80;
        smg[1] = smgduan[(ssec / 100) % 10];
        smg[0] = smgduan[(ssec / 10) % 10]; // 10ms位
        DisplayDelay(smg);
    }
}

/*******************************************************************************
* 函 数 名      : Timer0Init
* 函数功能      : 定时器初始化函数
* 输    入      : unsigned char
* 输    出      : 
*******************************************************************************/
void Timer0Init(u8 x)
{
    TMOD |= 0X02; // 设置工作方式为2，8位自动重装定时器,定时器读取内部时钟，计时器读取管脚脉冲
    TL0 = 0X00;   // 定时器0低八位赋初值
    TH0 = 0X00;   // 定时器0高八位赋初值
    ET0 = 1;      // 定时器0中断打开
    EA = 1;       // 总中断打开
    TR0 = x;      // 控制定时器，1为打开
}

/*******************************************************************************
* 函 数 名      : UsartInit
* 函数功能      : 定时器初始化函数
* 输    入      : unsigned char
* 输    出      : 
* 注            ：方式0的波特率 =  fosc/12，方式2的波特率 =（2SMOD/64）· fosc ，方式1的波特率 =（2SMOD/32）·（T1溢出率），方式3的波特率 =（2SMOD/32）·（T1溢出率）
*******************************************************************************/
void UsartInit(u8 x)
{
    TMOD |= 0X20; // 设置工作方式为2，8位自动重装定时器,定时器读取内部时钟，计时器读取管脚脉冲
    TL1 = 0XFF;   // 定时器1赋初值算波特率,溢出一次的时间=（0x100-初始值)*(12/fosc),溢出率=1/溢出一次的时间
    TH1 = 0XFF;   // 定时器1高赋初值,FFFF大概57600波特率
    PCON |= 0X80; // 开启SMOD
    SCON = 0X50;  // SCON工作方式1
    ES = 1;       // 串行通信中断打开
    EA = 1;       // 总中断打开
    TR1 = x;      // 控制定时器，1为打开
}

/*******************************************************************************
* 函 数 名       : Delay
* 函数功能		 : 延时函数
* 输    入       : unsigned int
* 输    出    	 : 
* 注			 ：S = 0.00001T + 0.00002 = 1E-05x + 2E-05
*******************************************************************************/
void Delay(u16 i)
{
    while (i--)
    {
    }
}

/*******************************************************************************
* 函 数 名      : DisplayDelay
* 函数功能      : 显示和延时函数
* 输    入      : unsigned int,unsigned char[0~7]为第0~7位数码管的显示数字
* 输    出      : 
*******************************************************************************/
void DisplayDelay(u8 smgxianshi[])
{
    u8 i;

    for (i = 0; i < 8; i++)
    {
        P0 = 0X00; //消隐
        switch (i) //位选，选择点亮的数码管，
        {
        case (7):
            LSA = 1;
            LSB = 1;
            LSC = 1;
            break; //显示第0位
        case (6):
            LSA = 0;
            LSB = 1;
            LSC = 1;
            break; //显示第1位
        case (5):
            LSA = 1;
            LSB = 0;
            LSC = 1;
            break; //显示第2位
        case (4):
            LSA = 0;
            LSB = 0;
            LSC = 1;
            break; //显示第3位
        case (3):
            LSA = 1;
            LSB = 1;
            LSC = 0;
            break; //显示第4位
        case (2):
            LSA = 0;
            LSB = 1;
            LSC = 0;
            break; //显示第5位
        case (1):
            LSA = 1;
            LSB = 0;
            LSC = 0;
            break; //显示第6位
        case (0):
            LSA = 0;
            LSB = 0;
            LSC = 0;
            break; //显示第7位
        }
        P0 = smgxianshi[i];
        Delay(85);
    }
}

/*******************************************************************************
* 函 数 名      : Timer0
* 函数功能      : 计数器0中断函数
* 输    入      : 
* 输    出      : 
*******************************************************************************/
void Timer0(void) interrupt 1
{
    sss += 1; // 记录+1次，18次为5ms

    if (sss >= 18)
    {
        ssec += 5; // +5ms
        sss = 0;

        if (ssec >= 1000)
        {
            sec += 1; // +1s
            ssec = 0;

            if (sec >= 60)
            {
                min += 1; // +1min
                sec = 0;

                if (min >= 60)
                {
                    h += 1; // +1h
                    min = 0;

                    if (h >= 24)
                    {
                        h = 0; // 24h归零
                    }
                }
            }
        }
    }
}

/*******************************************************************************
* 函 数 名      : Usart
* 函数功能      : 串行通信中断函数
* 输    入      : 
* 输    出      : 
*******************************************************************************/
void Usart(void) interrupt 4
{
    if (RI == 1) // 判断是否为接受数据触发中断
    {
        ReceiveDate[Rsec] = SBUF; // 接受数据
        Rsec++;                   // 接受了数据+1
        RI = 0;
    }
    if (TI == 1) // 判断是否为发送数据触发中断
    {
        Tsec++; // 发送了数据+1
        TI = 0; // 清除发送完成标志位
    }
}

// 2021年8月25号15点25分